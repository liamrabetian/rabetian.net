+++
categories = ["python", "database"]
comments = true
date = "2020-11-17T15:59:13-04:00"
draft = false
showpagemeta = true
showcomments = true
slug = ""
tags = ["python", "database", "engineering", "django"]
title = "How To Count Your Postgres Tables In Django"
description = "Postgres full table counts suck! let's do a faster version"

+++

When you want to do a full count on your tables in django, you often do it like this:  
```python
MyModel.objects.count()
```
which will produce a sql like this:  
```sql
SELECT COUNT(*) AS "__count" FROM "myapp_mymodel"
```
Which is pretty fine most of the time, but what happens if you have a lot of data and rows on your table? Then for instance in my experience it took 20 seconds to count all the rows in a table!! especially if you have a more complex query for your counts.  

There's an option in postgres called estimate counts, which will give you well, an estimate for your counts! So unless you want a very precise number of counts from your table, you're better off this way:  

The sql query would be like this:  
```sql
SELECT reltuples as approximate_row_count FROM pg_class WHERE relname = 'table_name';
```
Now what I needed was a function which receives a custom query and gives me back the approximate row counts. One smart person called Michael Fuhr has come up with this function to achieve this. So for more sophisticated queries you can use this function:  
```sql
CREATE FUNCTION count_estimate(query text) RETURNS integer AS
$func$
DECLARE
    rec   record;
    rows  integer;
BEGIN
    FOR rec IN EXECUTE 'EXPLAIN ' || query LOOP
        rows := substring(rec."QUERY PLAN" FROM ' rows=([[:digit:]]+)');
        EXIT WHEN rows IS NOT NULL;
    END LOOP;

    RETURN rows;
END
$func$ LANGUAGE plpgsql;
```
You first have to create this function in your postgres database and use it like this:  
```sql
SELECT count_estimate('Your custom query here');
```

Now what I've done in django to achieve all this is that at first I made sure I'm gonna create this stored procedure in my database by creating it in a migration.
```python
./manage.py makemigrations --empty myapp -n count_estimate_procedure
```
```python
# Generated by Django 2.2.11 on 2020-11-17 15:30

from django.db import migrations

STORED_PROCEDURE_SQL = """
CREATE FUNCTION count_estimate(query text) RETURNS integer AS
$func$
DECLARE
    rec   record;
    rows  integer;
BEGIN
    FOR rec IN EXECUTE 'EXPLAIN ' || query LOOP
        rows := substring(rec."QUERY PLAN" FROM ' rows=([[:digit:]]+)');
        EXIT WHEN rows IS NOT NULL;
    END LOOP;

    RETURN rows;
END
$func$ LANGUAGE plpgsql;
"""


class Migration(migrations.Migration):

    dependencies = [
        ("myapp", "0005_some_other_migration_file"),
    ]

    operations = [
        migrations.RunSQL(
            (STORED_PROCEDURE_SQL), ("DROP FUNCTION IF EXISTS count_estimate;")
        )
    ]
```

and then create a helper function to call this stored procedure from django:  
```python
def estimate_count_fast(sql):
    """ postgres really sucks at full table counts, this is a faster version"""
    cursor = connection.cursor()
    cursor.execute(sql)
    row = cursor.fetchone()
    return int(row[0])
```

Now you just have to write your count sql and give it to this function, in my case it was something like this:  
```python
MYMODEL_COUNT_SQL = """
SELECT count_estimate('SELECT * FROM myapp_mymodel 
WHERE NOT ("myapp_mymodel"."id" IN (SELECT U0."id" FROM "myapp_mymodel" U0 
LEFT OUTER JOIN "myanotherapp_myanothermodel" U1 ON (U0."id" = U1"mymodel_id") 
WHERE U1."somemodel_id" IS NULL))');
"""
```
Now it might not be a pretty sql, but you get my point. Don't you?!  

And use this query in my helper function:  
```python
estimate_count_fast(MYMODEL_COUNT_SQL)
```
And that's pretty much it. Wish you a very fast performant system!   